#!/usr/bin/env bash

set -e
[ -n "${JLENV_DEBUG}" ] && set -x

# Load the semver utility code
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
source ${DIR}/test_semver.bash

unset JLENV_VERSION
unset JLENV_DIR

JLENV_TEST_DIR="${BATS_TMPDIR}/jlenv"
PLUGIN="${JLENV_TEST_DIR}/root/plugins/jlenv-each"

# guard against executing this block twice due to bats internals
if [ "${JLENV_ROOT:=/}" != "${JLENV_TEST_DIR}/root" ]; then
  echo "Setting up test environment...."
  export JLENV_ROOT="${JLENV_TEST_DIR}/root"
  export HOME="${JLENV_TEST_DIR}/home"

  #export INSTALL_HOOK="${BATS_TEST_DIRNAME}/../etc/jlenv.d/install/autoalias.bash"
  #export UNINSTALL_HOOK="${BATS_TEST_DIRNAME}/../etc/jlenv.d/uninstall/autoalias.bash"

  PATH=/usr/bin:/bin:/usr/sbin:/sbin
  PATH="${JLENV_TEST_DIR}/bin:$PATH"
  PATH="${BATS_TEST_DIRNAME}/libexec:$PATH"
  PATH="${BATS_TEST_DIRNAME}/../libexec:$PATH"
  PATH="${BATS_TEST_DIRNAME}/libs/jlenv/libexec:$PATH"
  PATH="${BATS_TEST_DIRNAME}/libs/jlenv/test/libexec:$PATH"
  PATH="${JLENV_ROOT}/shims:$PATH"
  export PATH
  
  # To test upgrade we need jlenv root to be jlenv git clone
  # mkdir -p ${JLENV_ROOT}
  # pushd ${JLENV_ROOT}
  #   git init
  #   # git remote rm origin
  #   git remote add origin https://github.com/jlenv/jlenv.git
  #   git fetch --depth 1 origin master
  #   git checkout master
  #   git branch --set-upstream-to=origin/master master
  # popd

  # jlenv-prefix requires and .julia-version file for some reason.
  # echo 1.0.0 >${BATS_TEST_DIRNAME}/.julia-version
fi

teardown() {
  rm -rf "$JLENV_TEST_DIR"
}

flunk() {
  { if [ "$#" -eq 0 ]; then cat -
    else echo "$@"
    fi
  } | sed "s:${JLENV_TEST_DIR}:TEST_DIR:g" >&2
  return 1
}

# Creates fake julia version directories and version definition file.
# Version numbers is a semantic version convention: v1.0.0 and v1.0.0-rc1
create_versions() {
  local version
  local major
  local minor
  local patch
  local prerelease
  local released

  for v in $*
  do
    version="$(semver-get release $v)"
    major="$(semver-get major $version)"
    minor="$(semver-get minor $version)"
    patch="$(semver-get patch $version)"
    prerelease="$(semver-get prerel $version)"
    if [ -z "$prerelease" ]
    then
          # prerelease is empty
          released=1
    else
          # prerelease is NOT empty
          released=0
    fi
    d="$JLENV_TEST_DIR/root/versions/$v"
    mkdir -p "$d/bin"
    mkdir -p "$d/include/julia"
    tee "$d/include/julia/julia_version.h" > /dev/null <<EOF
// This is an autogenerated header file
#ifndef JL_VERSION_H
#define JL_VERSION_H
#define JULIA_VERSION_STRING "$version"
#define JULIA_VERSION_MAJOR $major
#define JULIA_VERSION_MINOR $minor
#define JULIA_VERSION_PATCH $patch
#define JULIA_VERSION_IS_RELEASE $released
#endif
EOF
    ln -nfs /bin/echo "$d/bin/julia"
    echo "Created version: $d"
  done
}

# Create to allow jlenv-prefix to work.  That logic needs to be reworked.
# the create-version code requires semver as the name
# mkdir -p "$JLENV_TEST_DIR/root/versions/system/bin"
# mkdir -p "$JLENV_TEST_DIR/root/versions/system/include"

# Check a given version string vJ.K.L or J.K.L is installed.
# copares to JULIA_VERSION_STRING from the julia header file 
# include/julia/julia_version.h
# -1 if given is newer than installed, 
#  0 if equal, 
#  1 if given older than installed. 
check_version_installed() {
  local major
  local minor
  local patch
  local prerelease
  local released
  local v
  local version
  local vi

  # ignore the first character if v
  if [[ ${version:0:1} == "v" ]] ; then 
    v="${version:1}"; 
  else
    v="${version}";
  fi
  # Ensure we have the release version number.
  # That is, remove prerelease and build data.
  v="$(semver-get release $v)"
  # Compare it to the versions installed - uses fake.
  vi=read_version_installed $v
  semver-compare $vi $v
}

# Given J.K.L reads the JULIA_VERSION_STRING from the julia header file
# include/julia/julia_version.h
read_version_installed(){
  $1
}


# # Creates test aliases
# create_alias() {
#   local alias="$1"
#   local version="$2"

#   mkdir -p "$JLENV_ROOT/versions"
#   ln -nfs "$JLENV_ROOT/versions/$version" "$JLENV_ROOT/versions/$alias"
# }

# assert_alias_version alias version

# assert_alias_version() {
#   if [ ! -f $JLENV_ROOT/versions/$1/RELEASE.txt ]
#   then
#     echo "Versions:"
#     (cd $JLENV_ROOT/versions ; ls -l)
#   fi
#   assert_equal "$2" "$(cat "$JLENV_ROOT/versions/$1/RELEASE.txt" 2>&1)"
# }

# assert_alias_missing() {
#   if [ -f $JLENV_ROOT/versions/$1/RELEASE.txt ]
#   then
#     assert_equal "no-version" "$(cat "$JLENV_ROOT/versions/$1/RELEASE.txt" 2>&1)"
#   fi
# }


# assert_success() {
#   if [ "$status" -ne 0 ]; then
#     flunk "output "$1" : command failed with exit status $status"
#   elif [ "$#" -gt 0 ]; then
#     assert_output "$1"
#   fi
# }

# assert_failure() {
#   if [ "$status" -eq 0 ]; then
#     flunk "expected failed exit status"
#   elif [ "$#" -gt 0 ]; then
#     assert_output "$1"
#   fi
# }

# assert_equal() {
#   if [ "$1" != "$2" ]; then
#     { echo "expected: $1"
#       echo "actual:   $2"
#     } | flunk
#   fi
# }

# assert_output() {
#   local expected
#   if [ $# -eq 0 ]; then expected="$(cat -)"
#   else expected="$1"
#   fi
#   assert_equal "$expected" "$output"
# }

# assert_line() {
#   if [ "$1" -ge 0 ] 2>/dev/null; then
#     assert_equal "$2" "${lines[$1]}"
#   else
#     local line
#     for line in "${lines[@]}"; do
#       if [ "$line" = "$1" ]; then return 0; fi
#     done
#     flunk "expected line \`$1'"
#   fi
# }

# assert_line_starts_with() {
#   if [ "$1" -ge 0 ] 2>/dev/null; then
#     assert_equal "$2" "${lines[$1]}"
#   else
#     local line
#     for line in "${lines[@]}"; do
#       if [ -n "${line#${1}}" ]; then return 0; fi
#     done
#     flunk "expected line \`$1'"
#   fi
# }

# refute_line() {
#   if [ "$1" -ge 0 ] 2>/dev/null; then
#     local num_lines="${#lines[@]}"
#     if [ "$1" -lt "$num_lines" ]; then
#       flunk "output has $num_lines lines"
#     fi
#   else
#     local line
#     for line in "${lines[@]}"; do
#       if [ "$line" = "$1" ]; then
#         flunk "expected to not find line \`$line'"
#       fi
#     done
#   fi
# }

# assert() {
#   if ! "$@"; then
#     flunk "failed: $@"
#   fi
# }
